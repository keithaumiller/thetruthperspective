<?php

/**
 * @file
 * News Extractor module - Enhanced architecture with separated services.
 * 
 * ARCHITECTURE:
 * - ScrapingService (Sensors): Handles Diffbot API and content extraction
 * - AIProcessingService (Processors): Handles Claude AI analysis and prompt building
 * - DataProcessingService (Levers): Handles field updates, taxonomy, and formatting
 * - NewsExtractionService (Orchestrator): Coordinates all services in pipeline
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\node\Entity\Node;

/**
 * Implements hook_help().
 */
function news_extractor_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.news_extractor':
      return '<p>' . t('Enhanced news extraction with separated scraping, AI processing, and data management services.') . '</p>';
  }
}

/**
 * Implements hook_feeds_process_alter().
 * Alter feed item data before it becomes a node.
 */
function news_extractor_feeds_process_alter(&$feed, $item, $entity_interface) {
  \Drupal::logger('news_extractor')->info('Enhanced news_extractor module - feeds_process_alter triggered');

  // Only process Article content type
  if ($entity_interface->getTarget()->bundle() !== 'article') {
    return;
  }

  $title_to_check = $item['title'] ?? '';
  $link_to_check = $item['link'] ?? '';

  // Use scraping service to validate URLs
  /** @var \Drupal\news_extractor\Service\ScrapingService $scraping_service */
  $scraping_service = \Drupal::service('news_extractor.scraping');

  // Skip invalid URLs
  if (!empty($item['link']) && !$scraping_service->isValidArticleUrl($item['link'])) {
    \Drupal::logger('news_extractor')->info('Skipping invalid article URL: @url', [
      '@url' => $item['link'],
    ]);
    $feed->skipItem($item);
    return;
  }

  // Skip items with blocked content or invalid titles
  if (_news_extractor_has_blocked_content($title_to_check, $link_to_check) ||
      _news_extractor_has_invalid_title($title_to_check)) {
    $feed->skipItem($item);
    return;
  }

  // Extract news source from feed data
  $news_source = _news_extractor_extract_news_source_from_feed($item);
  if (!empty($news_source) && $entity_interface->getTarget()->hasField('field_news_source')) {
    $entity_interface->getTarget()->set('field_news_source', $news_source);
    \Drupal::logger('news_extractor')->info('Set news source from feed: @source', [
      '@source' => $news_source,
    ]);
  }
}

/**
 * Implements hook_entity_insert().
 * Process new article entities.
 */
function news_extractor_entity_insert(EntityInterface $entity) {
  if ($entity->bundle() === 'article' && $entity->hasField('field_original_url')) {
    $original_url = $entity->get('field_original_url')->uri ?? '';
    
    if (!empty($original_url)) {
      // Use the orchestrator service for complete processing
      /** @var \Drupal\news_extractor\Service\NewsExtractionService $extraction_service */
      $extraction_service = \Drupal::service('news_extractor.extraction');
      $extraction_service->processArticle($entity, $original_url);
    }
  }
}

/**
 * Main extraction function using service architecture.
 * 
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The article entity to process.
 * @param string $url
 *   The article URL.
 * 
 * @return bool
 *   TRUE if processing was successful.
 */
function _news_extractor_extract_content(EntityInterface $entity, $url) {
  /** @var \Drupal\news_extractor\Service\NewsExtractionService $extraction_service */
  $extraction_service = \Drupal::service('news_extractor.extraction');
  
  return $extraction_service->processArticle($entity, $url);
}

/**
 * Bulk process articles using the new service architecture.
 * 
 * @param int $limit
 *   Maximum number of articles to process.
 * @param string $processing_type
 *   Type of processing: 'full', 'scrape_only', 'analyze_only', 'reprocess'.
 * 
 * @return array
 *   Processing statistics.
 */
function news_extractor_bulk_process_articles($limit = 20, $processing_type = 'full') {
  /** @var \Drupal\news_extractor\Service\NewsExtractionService $extraction_service */
  $extraction_service = \Drupal::service('news_extractor.extraction');
  
  $stats = [
    'processed' => 0,
    'successful' => 0,
    'failed' => 0,
    'skipped' => 0,
  ];

  // Find articles based on processing type
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'article')
    ->accessCheck(FALSE)
    ->range(0, $limit);

  // Customize query based on processing type
  switch ($processing_type) {
    case 'scrape_only':
      // Articles with URLs but no scraped data
      $query->condition('field_original_url.uri', '', '<>');
      $or_group = $query->orConditionGroup();
      $or_group->condition('field_json_scraped_article_data.value', '', '=');
      $or_group->condition('field_json_scraped_article_data.value', NULL, 'IS NULL');
      $query->condition($or_group);
      break;

    case 'analyze_only':
      // Articles with scraped data but no AI analysis
      $query->condition('field_json_scraped_article_data.value', '', '<>');
      $or_group = $query->orConditionGroup();
      $or_group->condition('field_ai_raw_response.value', '', '=');
      $or_group->condition('field_ai_raw_response.value', NULL, 'IS NULL');
      $query->condition($or_group);
      break;

    case 'reprocess':
      // Articles with AI responses for reprocessing
      $query->condition('field_ai_raw_response.value', '', '<>');
      break;

    case 'full':
    default:
      // Articles with URLs but incomplete processing
      $query->condition('field_original_url.uri', '', '<>');
      break;
  }

  $nids = $query->execute();

  foreach ($nids as $nid) {
    $node = Node::load($nid);
    if (!$node) {
      $stats['skipped']++;
      continue;
    }

    $stats['processed']++;
    $success = FALSE;

    try {
      switch ($processing_type) {
        case 'scrape_only':
          $url = $node->get('field_original_url')->uri;
          $success = $extraction_service->scrapeArticleOnly($node, $url);
          break;

        case 'analyze_only':
          $success = $extraction_service->analyzeArticleOnly($node);
          break;

        case 'reprocess':
          $success = $extraction_service->reprocessArticle($node);
          break;

        case 'full':
        default:
          $url = $node->get('field_original_url')->uri;
          $success = $extraction_service->processArticle($node, $url);
          break;
      }

      if ($success) {
        $stats['successful']++;
      } else {
        $stats['failed']++;
      }

    } catch (\Exception $e) {
      $stats['failed']++;
      \Drupal::logger('news_extractor')->error('Error processing node @nid: @error', [
        '@nid' => $nid,
        '@error' => $e->getMessage(),
      ]);
    }
  }

  \Drupal::logger('news_extractor')->info('Bulk processing (@type) complete: @stats', [
    '@type' => $processing_type,
    '@stats' => json_encode($stats),
  ]);

  return $stats;
}

/**
 * Get processing status for articles.
 * 
 * @param int $limit
 *   Number of articles to check.
 * 
 * @return array
 *   Status information for articles.
 */
function news_extractor_get_processing_status($limit = 10) {
  /** @var \Drupal\news_extractor\Service\NewsExtractionService $extraction_service */
  $extraction_service = \Drupal::service('news_extractor.extraction');
  
  $nids = \Drupal::entityQuery('node')
    ->condition('type', 'article')
    ->accessCheck(FALSE)
    ->sort('created', 'DESC')
    ->range(0, $limit)
    ->execute();

  $status_reports = [];
  foreach ($nids as $nid) {
    $node = Node::load($nid);
    if ($node) {
      $status_reports[] = $extraction_service->getProcessingStatus($node);
    }
  }

  return $status_reports;
}

// Include legacy functions for backward compatibility
require_once __DIR__ . '/news_extractor.legacy.php';
